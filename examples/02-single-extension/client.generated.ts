/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 * 
 * Auto-generated client functions from define.ts
 * These functions allow CLIENT to call SERVER functions (ServerFunctions interface)
 * and set up handlers for CLIENT functions (ClientFunctions interface)
 *
 * To regenerate this file, run:
 * bunx socketrpc-gen /Volumes/Data/Projects/socket-rpc/examples/02-single-extension/define.ts
 */

import type { Socket } from "socket.io-client";
import type { RpcError, UnsubscribeFunction } from "./types.generated";
import type { Product, CreateProductRequest } from "./define";

// === CLIENT HANDLER TYPES ===
/** Handler type for processing 'showError' events from server */
export type ShowErrorHandler = (socket: Socket, error: Error) => Promise<void>;
/** Handler type for processing 'showSuccess' events from server */
export type ShowSuccessHandler = (socket: Socket, message: string) => Promise<void>;
/** Handler type for processing 'getClientInfo' events from server */
export type GetClientInfoHandler = (socket: Socket) => Promise<{ userAgent: string; language: string; } | RpcError>;
/** Handler type for processing 'onProductUpdated' events from server */
export type OnProductUpdatedHandler = (socket: Socket, product: Product) => Promise<void>;
/** Handler type for processing 'refreshProducts' events from server */
export type RefreshProductsHandler = (socket: Socket) => Promise<void>;

// === CLIENT CALLING SERVER FUNCTIONS ===
/**
 * CLIENT calls SERVER: Emits 'ping' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<string | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function ping(socket: Socket, timeout: number = 5000): Promise<string | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('ping');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'getServerTime' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<number | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function getServerTime(socket: Socket, timeout: number = 5000): Promise<number | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getServerTime');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'getProduct' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} productId
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Product | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function getProduct(socket: Socket, productId: string, timeout: number = 5000): Promise<Product | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getProduct', productId);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'createProduct' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {CreateProductRequest} request
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Product | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function createProduct(socket: Socket, request: CreateProductRequest, timeout: number = 5000): Promise<Product | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('createProduct', request);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'listProducts' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Product[] | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function listProducts(socket: Socket, timeout: number = 5000): Promise<Product[] | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('listProducts');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

// === CLIENT HANDLER FUNCTIONS ===
/**
 * Sets up listener for 'showError' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {ShowErrorHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleShowError(socket: Socket, handler: ShowErrorHandler): UnsubscribeFunction {
    const listener = async (error: Error) => {
        try {
            await handler(socket, error);
        } catch (error) {
            console.error('[showError] Handler error:', error);
        }
    };
    socket.on('showError', listener);
    const cleanup = () => socket.off('showError', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'showSuccess' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {ShowSuccessHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleShowSuccess(socket: Socket, handler: ShowSuccessHandler): UnsubscribeFunction {
    const listener = async (message: string) => {
        try {
            await handler(socket, message);
        } catch (error) {
            console.error('[showSuccess] Handler error:', error);
        }
    };
    socket.on('showSuccess', listener);
    const cleanup = () => socket.off('showSuccess', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'getClientInfo' events from server with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {GetClientInfoHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleGetClientInfo(socket: Socket, handler: GetClientInfoHandler): UnsubscribeFunction {
    const listener = async (callback: (result: { userAgent: string; language: string; } | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[getClientInfo] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('getClientInfo', listener);
    const cleanup = () => socket.off('getClientInfo', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'onProductUpdated' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {OnProductUpdatedHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleOnProductUpdated(socket: Socket, handler: OnProductUpdatedHandler): UnsubscribeFunction {
    const listener = async (product: Product) => {
        try {
            await handler(socket, product);
        } catch (error) {
            console.error('[onProductUpdated] Handler error:', error);
        }
    };
    socket.on('onProductUpdated', listener);
    const cleanup = () => socket.off('onProductUpdated', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'refreshProducts' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {RefreshProductsHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRefreshProducts(socket: Socket, handler: RefreshProductsHandler): UnsubscribeFunction {
    const listener = async () => {
        try {
            await handler(socket);
        } catch (error) {
            console.error('[refreshProducts] Handler error:', error);
        }
    };
    socket.on('refreshProducts', listener);
    const cleanup = () => socket.off('refreshProducts', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'rpcError' events with async/await and try-catch. This handler is called whenever an RPC error occurs during function execution. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {(error: RpcError) => Promise<void>} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRpcError(socket: Socket, handler: (error: RpcError) => Promise<void>): UnsubscribeFunction {
    const listener = async (error: RpcError) => {
        try {
            await handler(error);
        } catch (handlerError) {
            console.error('[handleRpcError] Error in RPC error handler:', handlerError);
        }
    };
    socket.on('rpcError', listener);
    return () => socket.off('rpcError', listener);
}
