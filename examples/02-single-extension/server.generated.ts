/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 * 
 * Auto-generated server functions from define.ts
 * These functions allow SERVER to call CLIENT functions (ClientFunctions interface)
 * and set up handlers for SERVER functions (ServerFunctions interface)
 *
 * To regenerate this file, run:
 * bunx socketrpc-gen /Volumes/Data/Projects/socket-rpc/examples/02-single-extension/define.ts
 */

import type { Socket } from "socket.io";
import type { RpcError, UnsubscribeFunction } from "./types.generated";
import type { Product, CreateProductRequest } from "./define";

// === SERVER HANDLER TYPES ===
/** Handler type for processing 'ping' events from client */
export type PingHandler = (socket: Socket) => Promise<string | RpcError>;
/** Handler type for processing 'getServerTime' events from client */
export type GetServerTimeHandler = (socket: Socket) => Promise<number | RpcError>;
/** Handler type for processing 'getProduct' events from client */
export type GetProductHandler = (socket: Socket, productId: string) => Promise<Product | RpcError>;
/** Handler type for processing 'createProduct' events from client */
export type CreateProductHandler = (socket: Socket, request: CreateProductRequest) => Promise<Product | RpcError>;
/** Handler type for processing 'listProducts' events from client */
export type ListProductsHandler = (socket: Socket) => Promise<Product[] | RpcError>;

// === SERVER CALLING CLIENT FUNCTIONS ===
/**
 * SERVER calls CLIENT: Emits 'showError' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {Error} error
 */
export function showError(socket: Socket, error: Error): void {
    socket.emit('showError', error);
}

/**
 * SERVER calls CLIENT: Emits 'showSuccess' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} message
 */
export function showSuccess(socket: Socket, message: string): void {
    socket.emit('showSuccess', message);
}

/**
 * SERVER calls CLIENT: Emits 'getClientInfo' event to client with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ userAgent: string; language: string; } | RpcError>} A promise that resolves with the result from the client, or an RpcError if one occurred.
 */
export async function getClientInfo(socket: Socket, timeout: number = 5000): Promise<{ userAgent: string; language: string; } | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getClientInfo');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * SERVER calls CLIENT: Emits 'onProductUpdated' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {Product} product
 */
export function onProductUpdated(socket: Socket, product: Product): void {
    socket.emit('onProductUpdated', product);
}

/**
 * SERVER calls CLIENT: Emits 'refreshProducts' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 */
export function refreshProducts(socket: Socket): void {
    socket.emit('refreshProducts');
}

// === SERVER HANDLER FUNCTIONS ===
/**
 * Sets up listener for 'ping' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {PingHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handlePing(socket: Socket, handler: PingHandler): UnsubscribeFunction {
    const listener = async (callback: (result: string | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[ping] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('ping', listener);
    const cleanup = () => socket.off('ping', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'getServerTime' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {GetServerTimeHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleGetServerTime(socket: Socket, handler: GetServerTimeHandler): UnsubscribeFunction {
    const listener = async (callback: (result: number | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[getServerTime] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('getServerTime', listener);
    const cleanup = () => socket.off('getServerTime', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'getProduct' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {GetProductHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleGetProduct(socket: Socket, handler: GetProductHandler): UnsubscribeFunction {
    const listener = async (productId: string, callback: (result: Product | RpcError) => void) => {
        try {
            const result = await handler(socket, productId);
            callback(result);
        } catch (error) {
            console.error('[getProduct] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('getProduct', listener);
    const cleanup = () => socket.off('getProduct', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'createProduct' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {CreateProductHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleCreateProduct(socket: Socket, handler: CreateProductHandler): UnsubscribeFunction {
    const listener = async (request: CreateProductRequest, callback: (result: Product | RpcError) => void) => {
        try {
            const result = await handler(socket, request);
            callback(result);
        } catch (error) {
            console.error('[createProduct] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('createProduct', listener);
    const cleanup = () => socket.off('createProduct', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'listProducts' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {ListProductsHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleListProducts(socket: Socket, handler: ListProductsHandler): UnsubscribeFunction {
    const listener = async (callback: (result: Product[] | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[listProducts] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('listProducts', listener);
    const cleanup = () => socket.off('listProducts', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'rpcError' events with async/await and try-catch. This handler is called whenever an RPC error occurs during function execution. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {(error: RpcError) => Promise<void>} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRpcError(socket: Socket, handler: (error: RpcError) => Promise<void>): UnsubscribeFunction {
    const listener = async (error: RpcError) => {
        try {
            await handler(error);
        } catch (handlerError) {
            console.error('[handleRpcError] Error in RPC error handler:', handlerError);
        }
    };
    socket.on('rpcError', listener);
    return () => socket.off('rpcError', listener);
}
