/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 * 
 * Auto-generated client functions from define.ts
 * These functions allow CLIENT to call SERVER functions (ServerFunctions interface)
 * and set up handlers for CLIENT functions (ClientFunctions interface)
 *
 * To regenerate this file, run:
 * bunx socketrpc-gen /Volumes/Data/Projects/socket-rpc/examples/03-multi-level-extension/define.ts
 */

import type { Socket } from "socket.io-client";
import type { RpcError, UnsubscribeFunction } from "./types.generated";
import type { Order, CreateOrderRequest, OrderStatusUpdate } from "./define";
import { AuthToken, User } from "./platform.define";

// === CLIENT HANDLER TYPES ===
/** Handler type for processing 'showNotification' events from server */
export type ShowNotificationHandler = (socket: Socket, title: string, message: string) => Promise<void>;
/** Handler type for processing 'requestAuth' events from server */
export type RequestAuthHandler = (socket: Socket) => Promise<AuthToken | null | RpcError>;
/** Handler type for processing 'log' events from server */
export type LogHandler = (socket: Socket, level: "info" | "warn" | "error", message: string) => Promise<void>;
/** Handler type for processing 'getVersion' events from server */
export type GetVersionHandler = (socket: Socket) => Promise<string | RpcError>;
/** Handler type for processing 'onOrderStatusChanged' events from server */
export type OnOrderStatusChangedHandler = (socket: Socket, update: OrderStatusUpdate) => Promise<void>;
/** Handler type for processing 'refreshOrderList' events from server */
export type RefreshOrderListHandler = (socket: Socket) => Promise<void>;
/** Handler type for processing 'confirmPayment' events from server */
export type ConfirmPaymentHandler = (socket: Socket, amount: number) => Promise<boolean | RpcError>;

// === CLIENT CALLING SERVER FUNCTIONS ===
/**
 * CLIENT calls SERVER: Emits 'login' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} username
 * @param {string} password
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ user: User; token: AuthToken; } | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function login(socket: Socket, username: string, password: string, timeout: number = 5000): Promise<{ user: User; token: AuthToken; } | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('login', username, password);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'getCurrentUser' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<User | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function getCurrentUser(socket: Socket, timeout: number = 5000): Promise<User | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getCurrentUser');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'logout' event to server without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 */
export function logout(socket: Socket): void {
    socket.emit('logout');
}

/**
 * CLIENT calls SERVER: Emits 'healthCheck' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ status: "ok" | "degraded"; timestamp: number; } | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function healthCheck(socket: Socket, timeout: number = 5000): Promise<{ status: "ok" | "degraded"; timestamp: number; } | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('healthCheck');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'getOrder' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} orderId
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Order | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function getOrder(socket: Socket, orderId: string, timeout: number = 5000): Promise<Order | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getOrder', orderId);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'createOrder' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {CreateOrderRequest} request
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Order | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function createOrder(socket: Socket, request: CreateOrderRequest, timeout: number = 5000): Promise<Order | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('createOrder', request);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'cancelOrder' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} orderId
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Order | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function cancelOrder(socket: Socket, orderId: string, timeout: number = 5000): Promise<Order | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('cancelOrder', orderId);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'listOrders' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} userId
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<Order[] | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function listOrders(socket: Socket, userId: string, timeout: number = 5000): Promise<Order[] | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('listOrders', userId);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

// === CLIENT HANDLER FUNCTIONS ===
/**
 * Sets up listener for 'showNotification' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {ShowNotificationHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleShowNotification(socket: Socket, handler: ShowNotificationHandler): UnsubscribeFunction {
    const listener = async (title: string, message: string) => {
        try {
            await handler(socket, title, message);
        } catch (error) {
            console.error('[showNotification] Handler error:', error);
        }
    };
    socket.on('showNotification', listener);
    const cleanup = () => socket.off('showNotification', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'requestAuth' events from server with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {RequestAuthHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRequestAuth(socket: Socket, handler: RequestAuthHandler): UnsubscribeFunction {
    const listener = async (callback: (result: AuthToken | null | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[requestAuth] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('requestAuth', listener);
    const cleanup = () => socket.off('requestAuth', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'log' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {LogHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleLog(socket: Socket, handler: LogHandler): UnsubscribeFunction {
    const listener = async (level: "info" | "warn" | "error", message: string) => {
        try {
            await handler(socket, level, message);
        } catch (error) {
            console.error('[log] Handler error:', error);
        }
    };
    socket.on('log', listener);
    const cleanup = () => socket.off('log', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'getVersion' events from server with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {GetVersionHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleGetVersion(socket: Socket, handler: GetVersionHandler): UnsubscribeFunction {
    const listener = async (callback: (result: string | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[getVersion] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('getVersion', listener);
    const cleanup = () => socket.off('getVersion', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'onOrderStatusChanged' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {OnOrderStatusChangedHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleOnOrderStatusChanged(socket: Socket, handler: OnOrderStatusChangedHandler): UnsubscribeFunction {
    const listener = async (update: OrderStatusUpdate) => {
        try {
            await handler(socket, update);
        } catch (error) {
            console.error('[onOrderStatusChanged] Handler error:', error);
        }
    };
    socket.on('onOrderStatusChanged', listener);
    const cleanup = () => socket.off('onOrderStatusChanged', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'refreshOrderList' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {RefreshOrderListHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRefreshOrderList(socket: Socket, handler: RefreshOrderListHandler): UnsubscribeFunction {
    const listener = async () => {
        try {
            await handler(socket);
        } catch (error) {
            console.error('[refreshOrderList] Handler error:', error);
        }
    };
    socket.on('refreshOrderList', listener);
    const cleanup = () => socket.off('refreshOrderList', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'confirmPayment' events from server with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {ConfirmPaymentHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleConfirmPayment(socket: Socket, handler: ConfirmPaymentHandler): UnsubscribeFunction {
    const listener = async (amount: number, callback: (result: boolean | RpcError) => void) => {
        try {
            const result = await handler(socket, amount);
            callback(result);
        } catch (error) {
            console.error('[confirmPayment] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('confirmPayment', listener);
    const cleanup = () => socket.off('confirmPayment', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'rpcError' events with async/await and try-catch. This handler is called whenever an RPC error occurs during function execution. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {(error: RpcError) => Promise<void>} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRpcError(socket: Socket, handler: (error: RpcError) => Promise<void>): UnsubscribeFunction {
    const listener = async (error: RpcError) => {
        try {
            await handler(error);
        } catch (handlerError) {
            console.error('[handleRpcError] Error in RPC error handler:', handlerError);
        }
    };
    socket.on('rpcError', listener);
    return () => socket.off('rpcError', listener);
}
