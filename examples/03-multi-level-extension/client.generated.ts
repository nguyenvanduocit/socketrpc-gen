/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 *
 * Auto-generated client RPC from define.ts
 *
 * Usage:
 *   const client = createRpcClient(socket);
 *   client.handle.eventName(async (data) => { ... });
 *   client.server.methodName(args);
 *   client.dispose();
 *
 * To regenerate: bunx socketrpc-gen /Volumes/Data/Projects/socket-rpc/examples/03-multi-level-extension/define.ts
 */

import type { Socket } from "socket.io-client";
import type { RpcError } from "./types.generated";
import type { Order, CreateOrderRequest, OrderStatusUpdate } from "./define";
import type { User, AuthToken } from "./platform.define";

// === RPCCLIENT INTERFACE ===
/** Handler registration methods - implement these to handle calls from server */
export interface RpcClientHandle {
    /** Register handler for 'showNotification' - called by server */
    showNotification: (handler: (title: string, message: string) => Promise<void | RpcError>) => void;
    /** Register handler for 'requestAuth' - called by server */
    requestAuth: (handler: () => Promise<AuthToken | null | RpcError>) => void;
    /** Register handler for 'log' - called by server */
    log: (handler: (level: "info" | "warn" | "error", message: string) => Promise<void | RpcError>) => void;
    /** Register handler for 'getVersion' - called by server */
    getVersion: (handler: () => Promise<string | RpcError>) => void;
    /** Register handler for 'onOrderStatusChanged' - called by server */
    onOrderStatusChanged: (handler: (update: OrderStatusUpdate) => Promise<void | RpcError>) => void;
    /** Register handler for 'refreshOrderList' - called by server */
    refreshOrderList: (handler: () => Promise<void | RpcError>) => void;
    /** Register handler for 'confirmPayment' - called by server */
    confirmPayment: (handler: (amount: number) => Promise<boolean | RpcError>) => void;
    /** Register handler for RPC errors */
    rpcError: (handler: (error: RpcError) => void) => void;
}

/** Methods to call server */
export interface RpcClientServer {
    /** Call server's 'login' method */
    login: (username: string, password: string, timeout?: number) => Promise<{ user: User; token: AuthToken; } | RpcError>;
    /** Call server's 'getCurrentUser' method */
    getCurrentUser: (timeout?: number) => Promise<User | RpcError>;
    /** Call server's 'logout' method */
    logout: () => void;
    /** Call server's 'healthCheck' method */
    healthCheck: (timeout?: number) => Promise<{ status: "ok" | "degraded"; timestamp: number; } | RpcError>;
    /** Call server's 'getOrder' method */
    getOrder: (orderId: string, timeout?: number) => Promise<Order | RpcError>;
    /** Call server's 'createOrder' method */
    createOrder: (request: CreateOrderRequest, timeout?: number) => Promise<Order | RpcError>;
    /** Call server's 'cancelOrder' method */
    cancelOrder: (orderId: string, timeout?: number) => Promise<Order | RpcError>;
    /** Call server's 'listOrders' method */
    listOrders: (userId: string, timeout?: number) => Promise<Order[] | RpcError>;
}

/** Client RPC interface with ergonomic API. */
/** Use `.handle` to register handlers, `.server` to call server methods, and `.dispose()` to cleanup. */
export interface RpcClient {
    /** Register handlers for calls from server */
    readonly handle: RpcClientHandle;
    /** Call server methods */
    readonly server: RpcClientServer;
    /** The underlying socket instance */
    readonly socket: Socket;
    /** Whether this instance has been disposed */
    readonly disposed: boolean;
    /** Cleanup all registered handlers. Call this when done (e.g., in onBeforeUnmount or useEffect cleanup). */
    dispose(): void;
}

// === FACTORY FUNCTION ===
/**
 * Create a client RPC instance.
 *
 * Usage:
 * ```typescript
 * const client = createRpcClient(socket);
 *
 * // Register handlers for calls from server
 * client.handle.showNotification(async (title, message) => {
 *   // handle event
 * });
 *
 * // Call server methods
 * const result = await client.server.login(..., ...);
 *
 * // Cleanup when done
 * client.dispose();
 * ```
 * @param socket The socket instance
 * @returns RpcClient instance with .handle, .server, and .dispose()
 */
export function createRpcClient(socket: Socket): RpcClient {
    const unsubscribers: Array<() => void> = [];
    let _disposed = false;

    const checkDisposed = () => {
        if (_disposed) throw new Error('RpcClient has been disposed');
    };

    const handle: RpcClientHandle = {
        showNotification(handler: (title: string, message: string) => Promise<void | RpcError>) {
            checkDisposed();
            const listener = async (title: string, message: string) => {
                try {
                    const result = await handler(title, message);
                    if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                        socket.emit('rpcError', result);
                    }
                } catch (error) {
                    console.error('[showNotification] Handler error:', error);
                    socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('showNotification', listener);
            unsubscribers.push(() => socket.off('showNotification', listener));
        },
        requestAuth(handler: () => Promise<AuthToken | null | RpcError>) {
            checkDisposed();
            const listener = async (callback: (result: AuthToken | null | RpcError) => void) => {
                try {
                    const result = await handler();
                    callback(result);
                } catch (error) {
                    console.error('[requestAuth] Handler error:', error);
                    callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('requestAuth', listener);
            unsubscribers.push(() => socket.off('requestAuth', listener));
        },
        log(handler: (level: "info" | "warn" | "error", message: string) => Promise<void | RpcError>) {
            checkDisposed();
            const listener = async (level: "info" | "warn" | "error", message: string) => {
                try {
                    const result = await handler(level, message);
                    if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                        socket.emit('rpcError', result);
                    }
                } catch (error) {
                    console.error('[log] Handler error:', error);
                    socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('log', listener);
            unsubscribers.push(() => socket.off('log', listener));
        },
        getVersion(handler: () => Promise<string | RpcError>) {
            checkDisposed();
            const listener = async (callback: (result: string | RpcError) => void) => {
                try {
                    const result = await handler();
                    callback(result);
                } catch (error) {
                    console.error('[getVersion] Handler error:', error);
                    callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('getVersion', listener);
            unsubscribers.push(() => socket.off('getVersion', listener));
        },
        onOrderStatusChanged(handler: (update: OrderStatusUpdate) => Promise<void | RpcError>) {
            checkDisposed();
            const listener = async (update: OrderStatusUpdate) => {
                try {
                    const result = await handler(update);
                    if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                        socket.emit('rpcError', result);
                    }
                } catch (error) {
                    console.error('[onOrderStatusChanged] Handler error:', error);
                    socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('onOrderStatusChanged', listener);
            unsubscribers.push(() => socket.off('onOrderStatusChanged', listener));
        },
        refreshOrderList(handler: () => Promise<void | RpcError>) {
            checkDisposed();
            const listener = async () => {
                try {
                    const result = await handler();
                    if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                        socket.emit('rpcError', result);
                    }
                } catch (error) {
                    console.error('[refreshOrderList] Handler error:', error);
                    socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('refreshOrderList', listener);
            unsubscribers.push(() => socket.off('refreshOrderList', listener));
        },
        confirmPayment(handler: (amount: number) => Promise<boolean | RpcError>) {
            checkDisposed();
            const listener = async (amount: number, callback: (result: boolean | RpcError) => void) => {
                try {
                    const result = await handler(amount);
                    callback(result);
                } catch (error) {
                    console.error('[confirmPayment] Handler error:', error);
                    callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
                }
            };
            socket.on('confirmPayment', listener);
            unsubscribers.push(() => socket.off('confirmPayment', listener));
        },
        rpcError(handler: (error: RpcError) => void) {
            checkDisposed();
            const listener = (error: RpcError) => handler(error);
            socket.on('rpcError', listener);
            unsubscribers.push(() => socket.off('rpcError', listener));
        }
    };

    const server: RpcClientServer = {
        async login(username: string, password: string, timeout: number = 5000): Promise<{ user: User; token: AuthToken; } | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('login', username, password);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async getCurrentUser(timeout: number = 5000): Promise<User | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('getCurrentUser');
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        logout() {
            socket.emit('logout');
        },
        async healthCheck(timeout: number = 5000): Promise<{ status: "ok" | "degraded"; timestamp: number; } | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('healthCheck');
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async getOrder(orderId: string, timeout: number = 5000): Promise<Order | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('getOrder', orderId);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async createOrder(request: CreateOrderRequest, timeout: number = 5000): Promise<Order | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('createOrder', request);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async cancelOrder(orderId: string, timeout: number = 5000): Promise<Order | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('cancelOrder', orderId);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        },
        async listOrders(userId: string, timeout: number = 5000): Promise<Order[] | RpcError> {
            try {
                return await socket.timeout(timeout).emitWithAck('listOrders', userId);
            } catch (err) {
                return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
            }
        }
    };

    return {
        handle,
        server,
        get socket() { return socket; },
        get disposed() { return _disposed; },
        dispose() {
            if (_disposed) return;
            _disposed = true;
            unsubscribers.forEach(fn => fn());
            unsubscribers.length = 0;
        }
    };
}
