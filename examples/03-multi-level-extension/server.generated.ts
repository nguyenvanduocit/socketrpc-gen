/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 * 
 * Auto-generated server functions from define.ts
 * These functions allow SERVER to call CLIENT functions (ClientFunctions interface)
 * and set up handlers for SERVER functions (ServerFunctions interface)
 *
 * To regenerate this file, run:
 * bunx socketrpc-gen /Volumes/Data/Projects/socket-rpc/examples/03-multi-level-extension/define.ts
 */

import type { Socket } from "socket.io";
import type { RpcError, UnsubscribeFunction } from "./types.generated";
import type { Order, CreateOrderRequest, OrderStatusUpdate } from "./define";
import { User, AuthToken } from "./platform.define";

// === SERVER HANDLER TYPES ===
/** Handler type for processing 'login' events from client */
export type LoginHandler = (socket: Socket, username: string, password: string) => Promise<{ user: User; token: AuthToken; } | RpcError>;
/** Handler type for processing 'getCurrentUser' events from client */
export type GetCurrentUserHandler = (socket: Socket) => Promise<User | RpcError>;
/** Handler type for processing 'logout' events from client */
export type LogoutHandler = (socket: Socket) => Promise<void>;
/** Handler type for processing 'healthCheck' events from client */
export type HealthCheckHandler = (socket: Socket) => Promise<{ status: "ok" | "degraded"; timestamp: number; } | RpcError>;
/** Handler type for processing 'getOrder' events from client */
export type GetOrderHandler = (socket: Socket, orderId: string) => Promise<Order | RpcError>;
/** Handler type for processing 'createOrder' events from client */
export type CreateOrderHandler = (socket: Socket, request: CreateOrderRequest) => Promise<Order | RpcError>;
/** Handler type for processing 'cancelOrder' events from client */
export type CancelOrderHandler = (socket: Socket, orderId: string) => Promise<Order | RpcError>;
/** Handler type for processing 'listOrders' events from client */
export type ListOrdersHandler = (socket: Socket, userId: string) => Promise<Order[] | RpcError>;

// === SERVER CALLING CLIENT FUNCTIONS ===
/**
 * SERVER calls CLIENT: Emits 'showNotification' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} title
 * @param {string} message
 */
export function showNotification(socket: Socket, title: string, message: string): void {
    socket.emit('showNotification', title, message);
}

/**
 * SERVER calls CLIENT: Emits 'requestAuth' event to client with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<AuthToken | null | RpcError>} A promise that resolves with the result from the client, or an RpcError if one occurred.
 */
export async function requestAuth(socket: Socket, timeout: number = 5000): Promise<AuthToken | null | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('requestAuth');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * SERVER calls CLIENT: Emits 'log' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {"info" | "warn" | "error"} level
 * @param {string} message
 */
export function log(socket: Socket, level: "info" | "warn" | "error", message: string): void {
    socket.emit('log', level, message);
}

/**
 * SERVER calls CLIENT: Emits 'getVersion' event to client with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<string | RpcError>} A promise that resolves with the result from the client, or an RpcError if one occurred.
 */
export async function getVersion(socket: Socket, timeout: number = 5000): Promise<string | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getVersion');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * SERVER calls CLIENT: Emits 'onOrderStatusChanged' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {OrderStatusUpdate} update
 */
export function onOrderStatusChanged(socket: Socket, update: OrderStatusUpdate): void {
    socket.emit('onOrderStatusChanged', update);
}

/**
 * SERVER calls CLIENT: Emits 'refreshOrderList' event to client without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 */
export function refreshOrderList(socket: Socket): void {
    socket.emit('refreshOrderList');
}

/**
 * SERVER calls CLIENT: Emits 'confirmPayment' event to client with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} amount
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<boolean | RpcError>} A promise that resolves with the result from the client, or an RpcError if one occurred.
 */
export async function confirmPayment(socket: Socket, amount: number, timeout: number = 5000): Promise<boolean | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('confirmPayment', amount);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

// === SERVER HANDLER FUNCTIONS ===
/**
 * Sets up listener for 'login' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {LoginHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleLogin(socket: Socket, handler: LoginHandler): UnsubscribeFunction {
    const listener = async (username: string, password: string, callback: (result: { user: User; token: AuthToken; } | RpcError) => void) => {
        try {
            const result = await handler(socket, username, password);
            callback(result);
        } catch (error) {
            console.error('[login] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('login', listener);
    const cleanup = () => socket.off('login', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'getCurrentUser' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {GetCurrentUserHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleGetCurrentUser(socket: Socket, handler: GetCurrentUserHandler): UnsubscribeFunction {
    const listener = async (callback: (result: User | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[getCurrentUser] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('getCurrentUser', listener);
    const cleanup = () => socket.off('getCurrentUser', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'logout' events from client. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {LogoutHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleLogout(socket: Socket, handler: LogoutHandler): UnsubscribeFunction {
    const listener = async () => {
        try {
            await handler(socket);
        } catch (error) {
            console.error('[logout] Handler error:', error);
        }
    };
    socket.on('logout', listener);
    const cleanup = () => socket.off('logout', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'healthCheck' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {HealthCheckHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleHealthCheck(socket: Socket, handler: HealthCheckHandler): UnsubscribeFunction {
    const listener = async (callback: (result: { status: "ok" | "degraded"; timestamp: number; } | RpcError) => void) => {
        try {
            const result = await handler(socket);
            callback(result);
        } catch (error) {
            console.error('[healthCheck] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('healthCheck', listener);
    const cleanup = () => socket.off('healthCheck', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'getOrder' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {GetOrderHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleGetOrder(socket: Socket, handler: GetOrderHandler): UnsubscribeFunction {
    const listener = async (orderId: string, callback: (result: Order | RpcError) => void) => {
        try {
            const result = await handler(socket, orderId);
            callback(result);
        } catch (error) {
            console.error('[getOrder] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('getOrder', listener);
    const cleanup = () => socket.off('getOrder', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'createOrder' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {CreateOrderHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleCreateOrder(socket: Socket, handler: CreateOrderHandler): UnsubscribeFunction {
    const listener = async (request: CreateOrderRequest, callback: (result: Order | RpcError) => void) => {
        try {
            const result = await handler(socket, request);
            callback(result);
        } catch (error) {
            console.error('[createOrder] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('createOrder', listener);
    const cleanup = () => socket.off('createOrder', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'cancelOrder' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {CancelOrderHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleCancelOrder(socket: Socket, handler: CancelOrderHandler): UnsubscribeFunction {
    const listener = async (orderId: string, callback: (result: Order | RpcError) => void) => {
        try {
            const result = await handler(socket, orderId);
            callback(result);
        } catch (error) {
            console.error('[cancelOrder] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('cancelOrder', listener);
    const cleanup = () => socket.off('cancelOrder', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'listOrders' events from client with acknowledgment. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {ListOrdersHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleListOrders(socket: Socket, handler: ListOrdersHandler): UnsubscribeFunction {
    const listener = async (userId: string, callback: (result: Order[] | RpcError) => void) => {
        try {
            const result = await handler(socket, userId);
            callback(result);
        } catch (error) {
            console.error('[listOrders] Handler error:', error);
            callback({ message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('listOrders', listener);
    const cleanup = () => socket.off('listOrders', listener);
    socket.once('disconnect', cleanup);
    return () => {
        cleanup();
        socket.off('disconnect', cleanup);
    };
}

/**
 * Sets up listener for 'rpcError' events with async/await and try-catch. This handler is called whenever an RPC error occurs during function execution. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {(error: RpcError) => Promise<void>} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRpcError(socket: Socket, handler: (error: RpcError) => Promise<void>): UnsubscribeFunction {
    const listener = async (error: RpcError) => {
        try {
            await handler(error);
        } catch (handlerError) {
            console.error('[handleRpcError] Error in RPC error handler:', handlerError);
        }
    };
    socket.on('rpcError', listener);
    return () => socket.off('rpcError', listener);
}
