/**
 * ⚠️  DO NOT EDIT THIS FILE - IT IS AUTO-GENERATED ⚠️
 *
 * Auto-generated client functions from define.ts
 * These functions allow CLIENT to call SERVER functions (ServerFunctions interface)
 * and set up handlers for CLIENT functions (ClientFunctions interface)
 *
 * To regenerate this file, run:
 * bunx socketrpc-gen /Volumes/Data/Projects/socket-rpc/examples/04-zod-integration/define.ts
 */

import type { Socket } from "socket.io-client";
import type { RpcError, UnsubscribeFunction } from "./types.generated";

// === CLIENT HANDLER TYPES ===
/** Handler type for processing 'onProgress' events from server */
export type OnProgressHandler = (socket: Socket, update: { taskId: string; progress: number; message?: string | undefined; }) => Promise<void | RpcError>;
/** Handler type for processing 'onTaskComplete' events from server */
export type OnTaskCompleteHandler = (socket: Socket, task: { id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }) => Promise<void | RpcError>;
/** Handler type for processing 'onError' events from server */
export type OnErrorHandler = (socket: Socket, message: string, code: string) => Promise<void | RpcError>;

// === CLIENT CALLING SERVER FUNCTIONS ===
/**
 * CLIENT calls SERVER: Emits 'generate' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {{ prompt: string; maxTokens?: number | undefined; temperature?: number | undefined; }} request
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ text: string; finishReason: "stop" | "length" | "content_filter"; usage: { inputTokens: number; outputTokens: number; }; } | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function generate(socket: Socket, request: { prompt: string; maxTokens?: number | undefined; temperature?: number | undefined; }, timeout: number = 5000): Promise<{ text: string; finishReason: "stop" | "length" | "content_filter"; usage: { inputTokens: number; outputTokens: number; }; } | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('generate', request);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'createTask' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {{ title: string; description?: string | undefined; }} request
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; } | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function createTask(socket: Socket, request: { title: string; description?: string | undefined; }, timeout: number = 5000): Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; } | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('createTask', request);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'getTask' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} taskId
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; } | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function getTask(socket: Socket, taskId: string, timeout: number = 5000): Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; } | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('getTask', taskId);
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'listTasks' event to server with acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {number} timeout The timeout for the acknowledgment in milliseconds.
 * @returns {Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }[] | RpcError>} A promise that resolves with the result from the server, or an RpcError if one occurred.
 */
export async function listTasks(socket: Socket, timeout: number = 5000): Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }[] | RpcError> {
    try {
        return await socket.timeout(timeout).emitWithAck('listTasks');
    } catch (err) {
        return { message: err instanceof Error ? err.message : String(err), code: 'INTERNAL_ERROR', data: undefined };
    }
}

/**
 * CLIENT calls SERVER: Emits 'cancelTask' event to server without acknowledgment. Includes built-in error handling.
 * @param {Socket} socket The socket instance for communication.
 * @param {string} taskId
 */
export function cancelTask(socket: Socket, taskId: string): void {
    socket.emit('cancelTask', taskId);
}

// === CLIENT HANDLER FUNCTIONS ===
/**
 * Sets up listener for 'onProgress' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {OnProgressHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleOnProgress(socket: Socket, handler: OnProgressHandler): UnsubscribeFunction {
    const listener = async (update: { taskId: string; progress: number; message?: string | undefined; }) => {
        try {
            const result = await handler(socket, update);
            if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                socket.emit('rpcError', result);
            }
        } catch (error) {
            console.error('[onProgress] Handler error:', error);
            socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('onProgress', listener);
    return () => socket.off('onProgress', listener);
}

/**
 * Sets up listener for 'onTaskComplete' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {OnTaskCompleteHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleOnTaskComplete(socket: Socket, handler: OnTaskCompleteHandler): UnsubscribeFunction {
    const listener = async (task: { id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }) => {
        try {
            const result = await handler(socket, task);
            if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                socket.emit('rpcError', result);
            }
        } catch (error) {
            console.error('[onTaskComplete] Handler error:', error);
            socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('onTaskComplete', listener);
    return () => socket.off('onTaskComplete', listener);
}

/**
 * Sets up listener for 'onError' events from server. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {OnErrorHandler} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleOnError(socket: Socket, handler: OnErrorHandler): UnsubscribeFunction {
    const listener = async (message: string, code: string) => {
        try {
            const result = await handler(socket, message, code);
            if (result && typeof result === 'object' && 'code' in result && 'message' in result) {
                socket.emit('rpcError', result);
            }
        } catch (error) {
            console.error('[onError] Handler error:', error);
            socket.emit('rpcError', { message: error instanceof Error ? error.message : String(error), code: 'INTERNAL_ERROR', data: undefined });
        }
    };
    socket.on('onError', listener);
    return () => socket.off('onError', listener);
}

/**
 * Sets up listener for 'rpcError' events with async/await and try-catch. This handler is called whenever an RPC error occurs during function execution. Returns a function to remove the listener.
 * @param {Socket} socket The socket instance for communication.
 * @param {(socket: Socket, error: RpcError) => Promise<void>} handler The handler function to process incoming events.
 * @returns {UnsubscribeFunction} A function that removes the event listener when called
 */
export function handleRpcError(socket: Socket, handler: (socket: Socket, error: RpcError) => Promise<void>): UnsubscribeFunction {
    const listener = async (error: RpcError) => {
        try {
            await handler(socket, error);
        } catch (handlerError) {
            console.error('[handleRpcError] Error in RPC error handler:', handlerError);
        }
    };
    socket.on('rpcError', listener);
    return () => socket.off('rpcError', listener);
}

// === RPCCLIENT INTERFACE ===
/** Handler registration methods for client */
export interface RpcClientOn {
    /** Register handler for 'onProgress' events from server */
    onProgress: (handler: (update: { taskId: string; progress: number; message?: string | undefined; }) => Promise<void | RpcError>) => void;
    /** Register handler for 'onTaskComplete' events from server */
    onTaskComplete: (handler: (task: { id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }) => Promise<void | RpcError>) => void;
    /** Register handler for 'onError' events from server */
    onError: (handler: (message: string, code: string) => Promise<void | RpcError>) => void;
    /** Register handler for RPC errors */
    rpcError: (handler: (error: RpcError) => void) => void;
}

/** RPC call methods for client to call server */
export interface RpcClientCall {
    /** Call server's 'generate' method */
    generate: (request: { prompt: string; maxTokens?: number | undefined; temperature?: number | undefined; }, timeout?: number) => Promise<{ text: string; finishReason: "stop" | "length" | "content_filter"; usage: { inputTokens: number; outputTokens: number; }; } | RpcError>;
    /** Call server's 'createTask' method */
    createTask: (request: { title: string; description?: string | undefined; }, timeout?: number) => Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; } | RpcError>;
    /** Call server's 'getTask' method */
    getTask: (taskId: string, timeout?: number) => Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; } | RpcError>;
    /** Call server's 'listTasks' method */
    listTasks: (timeout?: number) => Promise<{ id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }[] | RpcError>;
    /** Call server's 'cancelTask' method */
    cancelTask: (taskId: string) => void;
}

/** Client RPC interface with ergonomic API. */
/** Use `.on` to register handlers, `.call` to make RPC calls, and `.dispose()` to cleanup. */
export interface RpcClient {
    /** Register handlers for incoming events */
    readonly on: RpcClientOn;
    /** Call server methods */
    readonly call: RpcClientCall;
    /** The underlying socket instance */
    readonly socket: Socket;
    /** Whether this instance has been disposed */
    readonly disposed: boolean;
    /** Cleanup all registered handlers. Call this when done (e.g., in onBeforeUnmount or useEffect cleanup). */
    dispose(): void;
}

// === FACTORY FUNCTION ===
/**
 * Create an ergonomic client RPC interface.
 *
 * Usage:
 * ```typescript
 * const client = createRpcClient(socket);
 *
 * // Register handlers
 * client.on.onProgress((update) => {
 *   // handle event
 * });
 *
 * // Make calls
 * const result = await client.call.generate(...);
 *
 * // Cleanup when done
 * client.dispose();
 * ```
 * @param socket The socket instance
 * @returns RpcClient instance with .on, .call, and .dispose()
 */
export function createRpcClient(socket: Socket): RpcClient {
    const unsubscribers: Array<() => void> = [];
    let _disposed = false;

    const checkDisposed = () => {
        if (_disposed) throw new Error('RpcClient has been disposed');
    };

    const on = {
        onProgress(handler: (update: { taskId: string; progress: number; message?: string | undefined; }) => Promise<void | RpcError>) {
            checkDisposed();
            unsubscribers.push(handleOnProgress(socket, async (socket, update) => handler(update)));
        },
        onTaskComplete(handler: (task: { id: string; title: string; description: string; status: "pending" | "in_progress" | "completed"; createdAt: string; }) => Promise<void | RpcError>) {
            checkDisposed();
            unsubscribers.push(handleOnTaskComplete(socket, async (socket, task) => handler(task)));
        },
        onError(handler: (message: string, code: string) => Promise<void | RpcError>) {
            checkDisposed();
            unsubscribers.push(handleOnError(socket, async (socket, message, code) => handler(message, code)));
        },
        rpcError(handler: (error: RpcError) => void) {
            checkDisposed();
            unsubscribers.push(handleRpcError(socket, async (_socket, error) => handler(error)));
        }
    };

    const call = {
        generate(request: { prompt: string; maxTokens?: number | undefined; temperature?: number | undefined; }, timeout: number = 5000) {
            return generate(socket, request, timeout);
        },
        createTask(request: { title: string; description?: string | undefined; }, timeout: number = 5000) {
            return createTask(socket, request, timeout);
        },
        getTask(taskId: string, timeout: number = 5000) {
            return getTask(socket, taskId, timeout);
        },
        listTasks(timeout: number = 5000) {
            return listTasks(socket, timeout);
        },
        cancelTask(taskId: string) {
            cancelTask(socket, taskId);
        }
    };

    return {
        on,
        call,
        get socket() { return socket; },
        get disposed() { return _disposed; },
        dispose() {
            if (_disposed) return;
            _disposed = true;
            unsubscribers.forEach(fn => fn());
            unsubscribers.length = 0;
        }
    };
}
